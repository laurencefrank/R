---
title: 'Data manipulation and pipes'
author: "Gerko Vink, Erik-Jan van Kesteren, Laurence Frank"
date: "Statistical Programming with R"
output:
  ioslides_presentation:
    fig_height: 5
    fig_width: 8
    logo: logo.png
    transition: faster
    smaller: true
  beamer_presentation: default
---

## This lecture

- Data manipulation

- Basic analysis (correlation & t-test)

- R model formula and classes

- Pipes

## New packages we use
```{r warning=FALSE, message=FALSE}
library(MASS)     # for the cats data
library(dplyr)    # data manipulation
library(haven)    # in/exporting data
library(magrittr) # pipes
```

<img src="pipe.jpg" style="display:block;width:200px;margin-left:auto;margin-right:auto"></img>

<img src="magrittr-vignette.png" style="display:block;width:200px;margin-left:auto;margin-right:auto"></img>


## New functions

- `transform()`: changing and adding columns
- `dplyr::filter()`: row-wise selection (of cases)
- `dplyr::arrange()`: order rows by values of a column or columns (low to high)
- `table()`: frequency tables
- `class()`: object class
- `levels()`: levels of a factor
- `order()`: data entries in increasing order
- `haven::read_sav()`: import SPSS data
- `cor()`: bivariate correlation
- `sample()`: drawing a sample
- `t.test()`: t-test 

# Data manipulation

## The cats data

Description (see `?cats`): The heart weights (in g) and body weights (in kg) of 144 adult cats (male and female) used for digitalis experiments. Digitalis is a medication used to treat heart failure and certain types of irregular heartbeat.
```{r}
head(cats)
```


```{r}
str(cats)
```

## The cats data

```{r}
summary(cats)
```


## How to get only Female cats?


```{r}
# With dplyr::filter
fem.cats <- dplyr::filter(cats, Sex == "F")

dim(fem.cats)

# With base R:
# fem.cats <- cats[cats$Sex == "F", ]
```

## How to get only *heavy* cats?
```{r}
heavy.cats <- dplyr::filter(cats, Bwt > 3)
dim(heavy.cats)
head(heavy.cats)

# With base R:
# heavy.cats2 <- cats[cats$Bwt > 3, ]
# or:
# heavy.cats3 <- subset(cats, Bwt > 3)
```

## Select cats with specified range of body weights
```{r}
dplyr::filter(cats, Bwt > 2.0 & Bwt < 2.2, Sex == "F")

```


## Working with factors
```{r}
class(cats$Sex)
levels(cats$Sex)
```

## Working with factors

Changing the level names:
```{r}
levels(cats$Sex) <- c("Female", "Male")

table(cats$Sex)
head(cats)
```

## Sorting with `dplyr::arrange()`

`dplyr::arrange()`sorts the rows of a data frame according to the order of one or more of the columns. 

```{r}

# sort cats by body weight (Bwt) from low to high values
sorted.cats <- dplyr::arrange(cats, Bwt)
head(sorted.cats)
```
## Sorting with `dplyr::arrange()`

`dplyr::arrange()`sorts the rows of a data frame according to the order of one or more of the columns. 

```{r}
# Sort the cats by Sex first and within Sex (1=female) by body weight (low to high)
sorted.cats.grouped <- dplyr::arrange(cats, Sex, Bwt)
head(sorted.cats.grouped)
```



## Combining matrices or dataframes
```{r message=FALSE}
# add column with id numbers
ID <- matrix(c(1:144), nrow=144, ncol=1)
```

```{r message=FALSE}
# add variable name for ID variable and change names of other variables
D <- dplyr::bind_cols(ID, cats)
names(D) <- c("ID", "Sex", "Bodyweigt", "Hartweight")
head(D)
```


# Basic analysis
## Correlation

```{r}
cor(cats[, -1])
```
With `[, -1]` we exclude the first column (female/male)

## Correlation

```{r}
cor.test(cats$Bwt, cats$Hwt)
```

What do we conclude?

## Correlation

```{r fig.height=5, fig.width=5, dev.args = list(bg = 'transparent'), fig.align='center'}
plot(cats$Bwt, cats$Hwt)
```

## T-test
Test the null hypothesis that the difference in mean heart weight between male and female cats is 0
```{r}
t.test(formula = Hwt ~ Sex, data = cats)
```

## T-test
```{r fig.height=5, fig.width=5, dev.args = list(bg = 'transparent'), fig.align='center'}
plot(formula = Hwt ~ Sex, data = cats)
```

## Linear regression

Remember the `boys` data from package `mice`. 

If we want to regress BMI (`bmi`) on weight (`wgt`), we would use the `lm()` function and the model formula `bmi ~ wgt`.

```{r echo=FALSE, message=FALSE, error=FALSE, warning=FALSE}
require(mice)
```


```{r}
lm(formula = bmi ~ wgt, data = boys)
```
## Scatterplot

```{r}
plot(formula = bmi ~ wgt, data = boys)
```

## Add a quadratic term
```{r}
lm(formula = bmi ~ wgt + I(wgt^2), data = boys)
```

## Why we need `I()` {.smaller}

Inside an R model formula, the `+`, `:`, and `^` operators are text objects and therefore behave differently than when used in calculations with numeric vectors. Using `I()` converts these operators to their numerical meaning.

```{r}
lm(bmi ~ wgt + wgt^2, data = boys)
lm(bmi ~ wgt + I(wgt^2), data = boys)
```

## Output of the `lm()` class

It is 'nicer' to store the output from the function in an object. The convention for regression models is an object called `fit`.

```{r}
fit <- lm(bmi ~ wgt + I(wgt^2), data = boys)
```

The object `fit` contains a lot more than just the regression weights. To inspect what is inside you can use

```{r}
ls(fit)
```

## Inspecting what is inside `fit`

Another approach to inspecting the contents of `fit` is the function `attributes()`

```{r}
attributes(fit)
```

The benefit of using `attributes()` is that it directly tells you the class of the object.

## Classes in R {.smaller}

```{r}
class(fit)
```

Classes are used for an object-oriented style of programming. This means that you can write a specific function that 

- has fixed requirements with respect to the input. 
- presents output or graphs in a predefined manner.

When a generic function `fun` is applied to an object with class attribute `c("first", "second")`, the system searches for a function called `fun.first` and, if it finds it, applies it to the object.

If no such function is found, a function called `fun.second` is tried. If no class name produces a suitable function, the function `fun.default` is used (if it exists). If there is no class attribute, the implicit class is tried, then the default method.

## Classes example: plotting without class

```{r, dev.args = list(bg = 'transparent')}
plot(bmi ~ wgt, data = boys)
```

## Classes example: plotting with class

```{r, dev.args = list(bg = 'transparent')}
plot(lm(bmi ~ wgt, data = boys), which = 1)
```

## Classes example: plotting with class

```{r, dev.args = list(bg = 'transparent')}
plot(lm(bmi ~ wgt, data = boys), which = 2)
```

## Classes example: plotting with class

```{r, dev.args = list(bg = 'transparent')}
plot(lm(bmi ~ wgt, data = boys), which = 4)
```

## Why is plot different for class `"lm"`?

The function `plot()` is called, but not used. Instead, because the linear model has class `"lm"`, `R` searches for the function `plot.lm()`.

If function `plot.lm()` would not exist, `R` tries to apply function `plot()` (which would have failed in this case because plot requires `x` and `y` as input)

`plot.lm()` is created by John Maindonald and Martin Maechler. They thought it would be useful to have a standard plotting environment for objects with class `"lm"`.

Since the elements that class `"lm"` returns are known, creating a generic function class is straightforward.


# Pipes

## This is a pipe:

```{r message=FALSE}
boys <- 
  read_sav("boys.sav") %>%
  head()
```

It effectively replaces `head(read_sav("boys.sav"))`.

## Why are pipes useful?
Let's assume that we want to load data, change a variable, filter cases and select columns. Without a pipe, this would look like
```{r}
boys  <- read_sav("boys.sav")
boys2 <- transform(boys, hgt = hgt / 100)
boys3 <- filter(boys2, age > 15)
boys4 <- subset(boys3, select = c(hgt, wgt, bmi))
```

With the pipe:
```{r}
boys <-
  read_sav("boys.sav") %>%
  transform(hgt = hgt/100) %>%
  filter(age > 15) %>%
  subset(select = c(hgt, wgt, bmi))
```

Benefit: a single object in memory, the steps are easy to follow and understand. 

## With pipes
Your code becomes more readable:

- data operations are structured from left-to-right and not from in-to-out
- nested function calls are avoided
- local variables and copied objects are avoided
- easy to add steps in the sequence

Keyboard shortcut:

* Windows/Linux: `ctrl + shift + m`
* Mac: `cmd + shift + m`

## What do pipes do:

Pipes create functions without nesting:

`f(x)` becomes `x %>% f()`
```{r }
set.seed(123)
mean(rnorm(10))

set.seed(123)
rnorm(10) %>% 
  mean()
```

## Pipes create functions without nesting

`f(x, y)` becomes `x %>% f(y)` 
```{r}
cor(boys, use = "pairwise.complete.obs")

boys %>% 
  cor(use = "pairwise.complete.obs")
```

## Pipes create functions without nesting

`h(g(f(x)))` becomes `x %>% f %>% g %>% h` 
```{r }
max(na.omit(subset(boys, select = wgt)))

boys %>% 
  subset(select = wgt) %>% 
  na.omit() %>% 
  max()
```

## Useful: outlier filtering
```{r}
nrow(cats)

# select the observations that fall outside the +/- SD around the mean
cats.outl <- 
  cats %>% 
  dplyr::filter(Hwt > mean(Hwt) + 3 * sd(Hwt) | Hwt < mean(Hwt) - 3 * sd(Hwt))

nrow(cats.outl)

# select the observations that fall within +/- 3 SD around the mean
cats.without.outl <- 
  cats %>% 
  dplyr::filter(Hwt < mean(Hwt) + 3 * sd(Hwt) & Hwt > mean(Hwt) - 3 * sd(Hwt))

nrow(cats.without.outl)
```
# More pipe stuff



## Pipes and the R model formula `~`

Sometimes the data we want to use, are "piped" in the wrong argument, see e.g.:
```{r eval=FALSE}
cats %>% 
  lm(Hwt ~ Bwt)
```
This leads to an error:

<font color="blue">Error in as.data.frame.default(data) : 

  cannot coerce class ‘"formula"’ to a data.frame</font>

The `%>%` pipe operator is intended to work with functions where each result is forwarded on to the **first** argument of the next function. For the function `lm()` the first argument is the model formula, which is a text object and not the data frame.

## Solution 1
We can use the `.` symbol to act as placeholder for the data:
```{r}
cats %>% 
  lm(Hwt ~ Bwt, data = .)
```

## Solution 2: the exposition `%$%` pipe


<img src="flow_pipe.png" alt="HTML5 Icon" width = 65%>

<center>
<img src="flow_$_pipe.png" alt="HTML5 Icon" width = 65%>
</center>




## Solution 2: the exposition `%$%` pipe
The exposition `%$%` pipe exposes the content(s) of the data frame (the variables) to the next function in the pipeline.

```{r}
# Now the code works without need of the placeholder

cats %$% 
  lm(Hwt ~ Bwt)

```

## Debugging pipelines {.smaller}
Sample 3 positions from the alphabet and show the position and the letter. If you don't know what's going on, run each statement separately!
```{r}
set.seed(123)
1:26

set.seed(123)
1:26 %>% 
  sample(3)

set.seed(123)
1:26 %>%
  sample(3) %>%
  paste(., LETTERS[.])

```

## Performing a t-test in a pipe
```{r message=FALSE}
cats %$%
  t.test(Hwt ~ Sex)
```
is the same as 
```{r eval=FALSE}
t.test(Hwt ~ Sex, data = cats)
```

## Storing a t-test from a pipe
```{r}
cats.test <- 
  cats %$%
  t.test(Bwt ~ Sex)

cats.test
```
# Practical 

