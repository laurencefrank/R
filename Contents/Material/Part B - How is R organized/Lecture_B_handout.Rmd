---
title: "Working with R"
author: "Gerko Vink, Laurence Frank"
date: "Statistical Programming with R"
output: 
  html_document:
    toc: true
    toc_depth: 5
    toc_float: true
    number_sections: false
---
<style type="text/css">

body{ /* Normal  */
      font-size: 12px;
  }
td {  /* Table  */
  font-size: 12px;
}
h1.title {
  font-size: 18px;
  color: DarkBlue;
}
h1 { /* Header 1 */
  font-size: 18px;
}
h2 { /* Header 2 */
    font-size: 18px;
}
h3 { /* Header 3 */
  font-size: 18px;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>

---

# Recap

## So far

This morning we have learned the basics of programming in `R`:

- assign elements to objects with `<-` (alt/option -)
- work with `RStudio` and `R Markdown`
- run code
- organize your work with projects in `RStudio`

```{r echo=FALSE}
set.seed(123)
```


## The help

-   Everything that is published on the Comprehensive `R` Archive
    Network (CRAN) and is aimed at `R` users, must be accompanied by a
    help file.

-   If you know the name of the function that performs an operation,
    e.g. `anova()`, then you just type `?anova` or `help(anova)` in the
    console.

-   If you do not know the name of the function: type `??` followed by
    your search criterion. For example `??anova` returns a list of all
    help pages that contain the word 'anova'
    
-   Some packages have cheat sheets, see in `R Studio`, Help menu -> Cheat Sheets    

-   Alternatively, the internet will tell you almost everything you'd
    like to know and sites such as <http://www.stackoverflow.com> and
    <http://www.stackexchange.com>, as well as `Google` can be of
    tremendous help (use 'R:' as a prefix in your search term).


# Working with objects in R

## Objects with more than one element
We can assign more than one element to a vector (in this case a 1-dimensional concatenation of numbers 1 through 5)
```{r}
a <- c(1, 2, 3, 4, 5)
a
b <- 1:5
b 
```

## More than one element, with characters
Characters (or character strings) in `R` are indicated by the double quote identifier. 
```{r}
a.new <- c(a, "A")
a.new
```
Notice the difference with `a` from the previous slide
```{r}
a
```

## Quickly identifying elements in vectors

```{r}
rep(a, 15)
```
### Calling elements in vectors

If we would want just the third element, we would type
```{r}
a[3]
```

## Multiple vectors in one object
This we would refer to as a matrix
```{r}
c <- matrix(a, nrow = 5, ncol = 2)
c
```

## Calling elements in matrices #1
```{r echo=FALSE}
c
```
The first row is called by
```{r}
c[1, ]
```
The second column is called by
```{r}
c[, 2]
```

## Calling elements in matrices #2
```{r echo=FALSE}
c
```
The intersection of the first row and second column is called by
```{r}
c[1, 2]
```
Square brackets [] are used to call elements, rows, columns.
[**a**, **b**]: **a** refers to the row number(s), **b** refers to the column number(s).

## Matrices with mixed numeric / character data
If we add a character column to matrix `c`; everything becomes a character:
```{r}
cbind(c, letters[1:5])
```

## Matrices with mixed numeric / character data
Alternatively, 
```{r}
cbind(c, c("a", "b", "c", "d", "e"))
```

Remember, matrices and vectors are numerical OR character objects. They can never contain both and still be used for numerical calculations. 

## Data frames
```{r}
d <- data.frame("V1" = rnorm(5),
                "V2" = rnorm(5, mean = 5, sd = 2), 
                "V3" = letters[1:5])
d
```

We 'filled' a dataframe with two randomly generated sets from the normal distribution - where $V1$ is standard normal and $V2 \sim N(5,2)$ - and a character set. 

## Data frames (continued)
Data frames can contain both numerical and character elements at the same time, although never in the same column. 

You can name the columns and rows in data frames (just like in matrices)
```{r}
row.names(d) <- c("row 1", "row 2", "row 3", "row 4", "row 5")
d
```

## Calling row elements in data frames

There are two ways to obtain row `3` from data frame `d`:
```{r}
d["row 3", ]
```

and
```{r}
d[3, ]
```

## Selecting columns in data frames
Both
```{r}
d[, "V2"] # and
d[, 2]
```
yield the second column. But we can also use `$` to call variable names in data frame objects
```{r}
d$V2
```

## Calling one element in data frame
```{r echo=FALSE}
d
```
### How can I select element "b" from matrix d?


```{r}
d[2,3]
```
Or:
```{r}
d[2, "V3"]
```

## Beyond two dimensions
If you wish to use numerical objects that have more than two dimensions, an array would be a suitable object. The following code yields a 3-dimensional array (2 rows, 4 columns and 3 matrices):
```{r}
e <- array(1:24, dim = c(2, 4, 3))
e
```

## Indexing an array
The square bracket identification works similarly to the identification of matrices and data frames, but with the added dimension(s). For example, 
```{r}
e[1, 3, 2]
```
yields the element in the first row of the third column in the second matrix. This is exactly the downside to an array: it is a series of matrices. 

In other words, characters and numerical elements may not be mixed. 

## Potential problem with array
If we replace the third matrix in the array by a character version of that matrix, we obtain
```{r}
e[, , 3] <- as.character(e[, , 3])
e
```

## Solution: a list
A list is a container for grouping related things together, e.g. vectors, matrices, data frame, other lists. Note that the elements in the list may be of different type (numeric, character) and dimensions.

```{r}
f <- list(a, letters[1:5])
f
```
Elements or objects within lists can be called by using double square brackets [[]]. For example, the first element in list `f` is object `a`
```{r}
f[[1]]
```


## Lists (continued)
We can simply add an object or element to an existing list
```{r}
f[[3]] <- d
f
```
to obtain a list with a numeric vector, a character vector and a data frame. 

## Lists (continued)
We can add names to the list as follows
```{r}
names(f) <- c("vector", "letters", "data frame")
f
```
## Calling elements in lists
Calling the vector (a) from the list can be done as follows:
```{r}
f[[1]]
f[["vector"]]
f$vector
```
## Logical operators
- Logical operators are signs that evaluate a statement, such as `==`, `<`, `>`, `<=`, `>=`, and `|` (OR) as well as `&` (AND). Typing `!` before a logical operator takes the complement of that action. 

- For example, if we would like to select elements out of matrix `c` that are larger than 3, we would type:
```{r}
c[c > 3]
```

## Logical operators

Symbol | Meaning
------ | ------
! | logical *not*
$\&$ | logical *and*
$|$ | logical *or* 
$<$ | less than
$<=$ | less than or equal to 
$>$ | greater than
$>=$ | greater than or equal to
$==$ | logical equals
$!=$ | not equal

## Why does a logical statement on a matrix return a vector?
```{r echo=FALSE}
c
```

```{r}
c > 3
```
The column values for `TRUE` may be of different length. A vector as a return is therefore more appropriate. 

## Logical operators (cont'd)
If we would like the elements that are smaller than 3 OR larger than 3, we could type
```{r echo=FALSE}
c
```

```{r}
c[c < 3 | c > 3] #c smaller than 3 or larger than 3
```
or
```{r}
c[c != 3] #c not equal to 3
```

## Logical operators (cont'd)
In fact, `c != 3` returns a matrix 
```{r echo=FALSE}
c != 3
```
Remember `c`?: 
```{r echo=FALSE}
c
```

## Things that cannot be done
- Things that have no representation in real number space (at least not without tremendous effort)
    - For example, the following code returns "Not a Number"
```{r}
0 / 0
```

- Also impossible are calculations based on missing values (NA's)
```{r}
mean(c(1, 2, NA, 4, 5))
```

## Standard solves for missing values
There are two easy ways to perform "listwise deletion":
```{r}
mean(c(1, 2, NA, 4, 5), na.rm = TRUE)
mean(na.omit(c(1, 2, NA, 4, 5)))
```

## Integers and floating points
In R there are two types of numbers: integers and [floating point numbers](https://floating-point-gui.de/formats/fp/).

Since computer memory is limited, you cannot store numbers with infinite precision. Numbers are therefore represented with floating point numbers.

Floating points cannot represent decimal fractions exactly in most cases, which means you will frequently find that exact matches fail. 
```{r}
(3 - 2.9)

(3 - 2.9) <= 0.1
```
## Floating point representation
Let's have a look at how the decimal fractions are actually represented as floating points. You can see this by asking a representation with 54 decimals.

```{r}
sprintf("%.54f",3 - 2.9)

sprintf("%.54f",0.1)

```

## How to work with floating points
The difference of 8.326673e-17 is smaller than the representable difference between two numbers whose value is close to 0.1. 

The smallest positive floating point number in R is: 2.220446e-16

```{r}
(3 - 2.9) - 0.1

 .Machine$double.eps
```

## How to work with floating points
You can verify whether the difference between two floating points is smaller than the smallest positive floating point number (2.220446e-16). 

Or use the `all.equal()` function which checks that the difference is close to the smallest floating point number.

```{r}
((3 - 2.9) - 0.1) < .Machine$double.eps

all.equal((3 - 2.9), 0.1)

```

# Practical

## Practical B

* Go to the course website and download the file "Practical B: template" (a Markdown file).

* Save the file in the project folder you created for this course, and, if necessary, open the R Project by clicking on the `.Rproj` file.

* Make the exercises, if possible without looking at the answers in the file "Practical B: solutions".

* In any case; ask for help when you feel help is needed. 



